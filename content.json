{"meta":{"title":null,"subtitle":"","description":"","author":null,"url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"page","slug":"page-1","date":"2020-11-05T09:11:43.000Z","updated":"2020-11-05T09:11:43.711Z","comments":true,"path":"2020/11/05/page-1/","link":"","permalink":"http://example.com/2020/11/05/page-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"page","date":"2020-11-05T09:08:52.465Z","updated":"2020-11-05T09:11:35.500Z","comments":true,"path":"2020/11/05/page/","link":"","permalink":"http://example.com/2020/11/05/page/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"page","slug":"1","date":"2020-11-05T09:08:52.000Z","updated":"2020-11-05T09:11:37.954Z","comments":true,"path":"2020/11/05/1/","link":"","permalink":"http://example.com/2020/11/05/1/","excerpt":"","text":"一、冒泡排序 冒泡排序的思路：遍历数组，然后将最大数沉到最底部；时间复杂度：O(N^2)；空间复杂度：O(1) 123456789101112131415161718192021222324function BubbleSort(arr) &#123; if(arr == null || arr.length &lt;= 0)&#123; return []; &#125; var len = arr.length; for(var end = len - 1; end &gt; 0; end--)&#123; for(var i = 0; i &lt; end; i++) &#123; if(arr[i] &gt; arr[i + 1])&#123; swap(arr, i, i + 1); &#125; &#125; &#125; return arr;&#125;function swap(arr, i, j)&#123; // var temp = arr[i]; // arr[i] = arr[j]; // arr[j] = temp; //交换也可以用异或运算符 arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j];&#125;复制代码 二、选择排序 选择排序的实现思路：遍历数组，把最小数放在头部；时间复杂度：O(N^2)；空间复杂度：O(1) 1234567891011121314151617181920212223function SelectionSort(arr) &#123; if(arr == null || arr.length &lt; 0) &#123; return []; &#125; for(var i = 0; i &lt; arr.length - 1; i++) &#123; var minIndex = i; for(var j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; &#125; swap(arr, i, minIndex); &#125; return arr;&#125;function swap(arr, i, j) &#123; if (i === j) &#123; return; &#125; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j];&#125;复制代码 三、插入排序 插入排序实现思路：将一个新的数，和前面的比较，只要当前数小于前一个则和前一个交换位置，否则终止；时间复杂度：O(N^2)；空间复杂度：O(1) 12345678910111213141516171819function insertSort(arr) &#123; if(arr == null || arr.length &lt;= 0)&#123; return []; &#125; var len = arr.length; for(var i = 1; i &lt; len; i++) &#123; for(var j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; swap(arr, j, j + 1); &#125; &#125; return arr;&#125;function swap(arr, i, j)&#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;复制代码 四、归并排序 归并排序的思路：1.先左侧部分排好序2.再右侧部分排好序3.再准备一个辅助数组，用外排的方式，小的开始填，直到有个动到末尾，将另一个数组剩余部分拷贝到末尾4.再将辅助数组拷贝回原数组时间复杂度:O(N * logN)空间复杂度:O(N) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#x2F;&#x2F; 递归实现function mergeSort(arr)&#123; if(arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 0)&#123; return []; &#125; sortProcess(arr, 0, arr.length - 1); return arr;&#125;function sortProcess(arr, L, R)&#123; &#x2F;&#x2F;递归的终止条件，就是左右边界索引一样 if(L &#x3D;&#x3D; R)&#123; return; &#125; var middle &#x3D; L + ((R - L) &gt;&gt; 1);&#x2F;&#x2F;找出中间值 sortProcess(arr, L, middle);&#x2F;&#x2F;对左侧部分进行递归 sortProcess(arr, middle + 1, R);&#x2F;&#x2F;对右侧部分进行递归 merge(arr, L, middle, R);&#x2F;&#x2F;然后利用外排方式进行结合&#125;function merge(arr, L, middle, R)&#123; var help &#x3D; []; var l &#x3D; L; var r &#x3D; middle + 1; var index &#x3D; 0; &#x2F;&#x2F;利用外排方式进行 while(l &lt;&#x3D; middle &amp;&amp; r &lt;&#x3D; R)&#123; help[index++] &#x3D; arr[l] &lt; arr[r] ? arr[l++] : arr[r++]; &#125; while(l &lt;&#x3D; middle)&#123; help.push(arr[l++]); &#125; while(r &lt;&#x3D; R)&#123; help.push(arr[r++]); &#125; for(var i &#x3D; 0; i &lt; help.length; i++) &#123; arr[L + i] &#x3D; help[i]; &#125; &#x2F;&#x2F;arr.splice(L, help.length, ...help);&#x2F;&#x2F;这个利用了ES6的语法&#125;复制代码&#x2F;&#x2F; 循环实现function mergeSort(arr)&#123; if(arr &#x3D;&#x3D;null || arr.length &lt;&#x3D; 0)&#123; return []; &#125; var len &#x3D; arr.length; &#x2F;&#x2F;i每次乘2，是因为每次合并以后小组元素就变成两倍个了 for(var i &#x3D; 1; i &lt; len; i *&#x3D; 2)&#123; var index &#x3D; 0;&#x2F;&#x2F;第一组的起始索引 while( 2 * i + index &lt;&#x3D; len)&#123; index +&#x3D; 2 * i; merge(arr, index - 2 * i, index - i, index); &#125; &#x2F;&#x2F;说明剩余两个小组，但其中一个小组数据的数量已经不足2的幂次方个 if(index + i &lt; len)&#123; merge(arr, index, index + i, len); &#125; &#125; return arr;&#125;&#x2F;&#x2F;利用外排的方式进行结合function merge(arr, start, mid, end)&#123; &#x2F;&#x2F;新建一个辅助数组 var help &#x3D; []; var l &#x3D; start, r &#x3D; mid; var i &#x3D; 0; while(l &lt; mid &amp;&amp; r &lt; end)&#123; help[i++] &#x3D; arr[l] &lt; arr[r] ? arr[l++] : arr[r++]; &#125; while(l &lt; mid)&#123; help[i++] &#x3D; arr[l++]; &#125; while(r &lt; end)&#123; help[i++] &#x3D; arr[r++]; &#125; for(var j &#x3D; 0; j &lt; help.length; j++)&#123; arr[start + j] &#x3D; help[j]; &#125;&#125;复制代码 五、快速排序 快速排序实现思路：随机取出一个值进行划分，大于该值放右边，小于该值放左边（该算法在经典快排的基础上经过荷兰国旗思想和随机思想进行了改造）时间复杂度：O(N*logN)空间复杂度：O(logN) 12345678910111213141516171819202122232425262728293031323334353637383940function quickSort(arr) &#123; if(arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 0)&#123; return []; &#125; quick(arr, 0, arr.length - 1);&#125;function quick(arr, L, R)&#123; &#x2F;&#x2F;递归结束条件是L &gt;&#x3D; R if(L &lt; R)&#123; &#x2F;&#x2F;随机找一个值，然后和最后一个值进行交换，将经典排序变为快速排序 swap(arr, L + Math.floor(Math.random() * (R - L + 1)), R); &#x2F;&#x2F;利用荷兰国旗问题获得划分的边界，返回的值是小于区域的最大索引和大于区域的最小索引，在这利用荷兰国旗问题将等于区域部分就不用动了 var tempArr &#x3D; partition(arr, L, R, arr[R]); quick(arr, L, tempArr[0]); quick(arr, tempArr[1], R); &#125;&#125;&#x2F;&#x2F;返回值是小于区域最后的索引和大于区域的第一个索引function partition(arr, L, R, num)&#123; var less &#x3D; L - 1; var more &#x3D; R + 1; var cur &#x3D; L; while(cur &lt; more)&#123; if(arr[cur] &lt; num)&#123; swap(arr, ++less, cur++); &#125;else if(arr[cur] &gt; num) &#123; swap(arr, --more, cur); &#125;else&#123; cur++; &#125; &#125; return [less, more];&#125;function swap(arr, i, j)&#123; var temp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; temp;&#125;复制代码 六、堆排序 堆排序思路：1.让数组变成大根堆2.把最后一个位置和堆顶做交换3.则最大值在最后，则剩下部分做heapify，则重新调整为大根堆，则堆顶位置和该部分最后位置做交换4.重复进行，直到减完，则这样最后就调整完毕，整个数组排完序（为一个升序）时间复杂度:O(N * logN)空间复杂度:O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function heapSort(arr) &#123; if(arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 0) &#123; return []; &#125; &#x2F;&#x2F;首先是建立大顶堆的过程 for(var i &#x3D; 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i); &#125; var size &#x3D; arr.length;&#x2F;&#x2F;这个值用来指定多少个数组成堆，当得到一个排序的值后这个值减一 &#x2F;&#x2F;将堆顶和最后一个位置交换 &#x2F;** * 当大顶堆建立完成后，然后不断将最后一个位置和堆顶交换； * 这样最大值就到了最后，则剩下部分做heapify，重新调整为大根堆，则堆顶位置和倒数第二个位置交换，重复进行，直到全部排序完毕*&#x2F; &#x2F;&#x2F;由于前面已经是大顶堆，所以直接交换 swap(arr, 0, --size); while(size &gt; 0) &#123; &#x2F;&#x2F;重新变成大顶堆 heapify(arr, 0, size); &#x2F;&#x2F;进行交换 swap(arr, 0, --size); &#125;&#125;&#x2F;&#x2F;加堆过程中function heapInsert(arr, index) &#123; &#x2F;&#x2F;比较当前位置和其父位置，若大于其父位置，则进行交换，并将索引移动到其父位置进行循环，否则跳过 &#x2F;&#x2F;结束条件是比父位置小或者到达根节点处 while(arr[index] &gt; arr[parseInt((index - 1) &#x2F; 2)])&#123; &#x2F;&#x2F;进行交换 swap(arr, index, parseInt((index - 1) &#x2F; 2)); index &#x3D; parseInt((index - 1) &#x2F; 2); &#125;&#125;&#x2F;&#x2F;减堆过程&#x2F;** * size指的是这个数组前多少个数构成一个堆 * 如果你想把堆顶弹出，则把堆顶和最后一个数交换，把size减1，然后从0位置经历一次heapify，调整一下，剩余部分变成大顶堆*&#x2F;function heapify(arr, index, size) &#123; var left &#x3D; 2 * index + 1; while(left &lt; size) &#123; var largest &#x3D; (left + 1 &lt; size &amp;&amp; arr[left] &lt; arr[left + 1]) ? left + 1 : left; largest &#x3D; arr[index] &gt; arr[largest] ? index : largest; &#x2F;&#x2F;如果最大值索引和传进来索引一样，则该值到达指定位置，直接结束循环 if(index &#x3D;&#x3D; largest) &#123; break; &#125; &#x2F;&#x2F;进行交换，并改变索引和其左子节点 swap(arr, index, largest); index &#x3D; largest; left &#x3D; 2 * index + 1; &#125;&#125;function swap(arr, i, j) &#123; var temp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; temp;&#125;复制代码 七、桶排序 桶排序会经历三次遍历：准备一个数组、遍历一遍数组、重构一遍数组，是非基于比较的排序，下面以一个问题来阐述其思路。问题： 给定一个数组，求如果排序之后，相邻两个数的最大差值，要求时间复杂度O(N),且要求不能用基于比较的排序 思路：1.准备桶：数组中有N个数就准备N+1个桶2.遍历一遍数组，找到最大值max和最小值min 。若min = max，则差值=0；若min≠max，则最小值放在0号桶，最大值放在N号桶，剩下的数属于哪个范围就进哪个桶3.根据鸽笼原理，则肯定有一个桶为空桶，设计该桶的目的是为了否定最大值在一个桶中，则最大差值的两个数一定来自于两个桶，但空桶两侧并不一定是最大值4.所以只记录所有进入该桶的最小值min和最大值max和一个布尔值表示该桶有没有值5.然后遍历这个数组，如果桶是空的，则跳到下一个数，如果桶非空，则找前一个非空桶，则最大差值=当前桶min - 上一个非空桶max，用全局变量更新最大值时间复杂度：O(N)空间复杂度：O(N) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function maxGap(arr) &#123; if(arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 0) &#123; return 0; &#125; var len &#x3D; arr.length; var max &#x3D; -Infinity, min &#x3D; Infinity; &#x2F;&#x2F;遍历一遍数组,找到最大值max和最小值min for(var i &#x3D; 0; i &lt; len; i++) &#123; max &#x3D; max &gt; arr[i] ? max : arr[i]; min &#x3D; min &gt; arr[i] ? arr[i] : min; &#125; &#x2F;&#x2F;若min &#x3D; max,则差值为0; if(min &#x3D;&#x3D; max) &#123; return 0; &#125; var hasNum &#x3D; new Array(len + 1); var mins &#x3D; new Array(len + 1); var maxs &#x3D; new Array(len + 1); var bid &#x3D; 0;&#x2F;&#x2F;指定桶的编号 for(var i &#x3D; 0; i &lt; len; i++) &#123; bid &#x3D; bucket(arr[i], min, max, len);&#x2F;&#x2F;获得该值是在哪个桶&#x2F;&#x2F;由于有N+1个桶，所以间隔就是N个，所以此处除以的是len，然后通过这个函数得到应该放到哪个桶里 maxs[bid] &#x3D; hasNum[bid] ? Math.max(arr[i], maxs[bid]) : arr[i]; mins[bid] &#x3D; hasNum[bid] ? Math.min(arr[i], mins[bid]) : arr[i]; hasNum[bid] &#x3D; true; &#125; var res &#x3D; 0; var lastMax &#x3D; maxs[0]; for(var i &#x3D; 0; i &lt; len + 1; i++) &#123; if(hasNum[i]) &#123; res &#x3D; Math.max(mins[i] - lastMax, res); lastMax &#x3D; maxs[i]; &#125; &#125; return res;&#125;&#x2F;&#x2F;获得桶号&#x2F;&#x2F;这个函数用于判断在哪个桶中，参数分别为值、最小值、最大值、桶间隔function bucket(value, min, max, len) &#123; return parseInt((value - min) &#x2F; ((max - min) &#x2F; len));&#125;复制代码 八、new 12345678910111213141516function New (Fn, ...arg) &#123; &#x2F;&#x2F; 一个新的对象被创建 const result &#x3D; &#123;&#125;; &#x2F;&#x2F; 该对象的__proto__属性指向该构造函数的原型 if (Fn.prototype !&#x3D;&#x3D; null) &#123; Object.setPrototypeOf(result, Fn.prototype); &#125; &#x2F;&#x2F; 将执行上下文（this）绑定到新创建的对象中 const returnResult &#x3D; Fn.apply(result, arg); &#x2F;&#x2F; 如果构造函数有返回值，那么这个返回值将取代第一步中新创建的对象。否则返回该对象 if ((typeof returnResult &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof returnResult &#x3D;&#x3D;&#x3D; &quot;function&quot;) &amp;&amp; returnResult !&#x3D;&#x3D; null) &#123; return returnResult; &#125; return result;&#125;复制代码 九、instanceof 123456789101112function Instanceof(left, right) &#123; let leftVal &#x3D; Object.getPrototypeOf(left); const rightVal &#x3D; right.prototype; while (leftVal !&#x3D;&#x3D; null) &#123; if (leftVal &#x3D;&#x3D;&#x3D; rightVal) return true; leftVal &#x3D; Object.getPrototypeOf(leftVal); &#125; return false;&#125;复制代码 十、 Object.create() 123456789101112131415Object.ObjectCreate &#x3D; (proto, propertiesObject)&#x3D;&gt; &#123; &#x2F;&#x2F; 对输入进行检测 if (typeof proto !&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof proto !&#x3D;&#x3D; &#39;function&#39; &amp;&amp; proto !&#x3D;&#x3D; null) &#123; throw new Error(&#96;Object prototype may only be an Object or null:$&#123;proto&#125;&#96;); &#125; &#x2F;&#x2F; 新建一个对象 const result &#x3D; &#123;&#125;; &#x2F;&#x2F; 将该对象的原型设置为proto Object.setPrototypeOf(result, proto); &#x2F;&#x2F; 将属性赋值给该对象 Object.defineProperties(result, propertiesObject); &#x2F;&#x2F; 返回该对象 return result;&#125;复制代码 十一、 Object assign()![img](data:image/svg+xml;utf8,) 1234567891011121314151617181920212223242526272829303132333435363738394041function ObjectAssign(target, ...sources) &#123; &#x2F;&#x2F; 对第一个参数的判断，不能为undefined和null if (target &#x3D;&#x3D;&#x3D; undefined || target &#x3D;&#x3D;&#x3D; null) &#123; throw new TypeError(&#39;cannot convert first argument to object&#39;); &#125; &#x2F;&#x2F; 将第一个参数转换为对象(不是对象转换为对象) const targetObj &#x3D; Object(target); &#x2F;&#x2F; 将源对象(source)自身的所有可枚举属性复制到目标对象（target） for (let i &#x3D; 0; i &lt; sources.length; i++) &#123; let source &#x3D; sources[i]; &#x2F;&#x2F; 对于undefined和null在源角色中不会报错，会直接跳过 if (source !&#x3D;&#x3D; undefined &amp;&amp; source !&#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 将源角色转换成对象 &#x2F;&#x2F; 需要将源角色自身的可枚举属性（包含Symbol值的属性）进行复制 &#x2F;&#x2F; Reflect.ownKeys(obj) 返回一个数组，包含对象自身的所有属性，不管属性名是Symbol还是字符串，也不管是否可枚举 const keysArray &#x3D; Reflect.ownKeys(Object(source)); for (let nextIndex &#x3D; 0; nextIndex &lt; keysArray.length; nextIndex ++) &#123; const nextKey &#x3D; keysArray[nextIndex]; &#x2F;&#x2F; 去除不可枚举属性 const desc &#x3D; Object.getOwnPropertyDescriptor(source, nextKey); if (desc !&#x3D;&#x3D; undefined &amp;&amp; desc.enumerable) &#123; &#x2F;&#x2F; 后面的属性会覆盖前面的属性 targetObj[nextKey] &#x3D; source[nextKey]; &#125; &#125; &#125; &#125; return targetObj;&#125;&#x2F;&#x2F; 由于挂载到Object的assign是不可枚举的,直接挂载上去是可枚举的，所以采用这种方式if (typeof Object.myAssign !&#x3D;&#x3D; &#39;function&#39;) &#123; Object.defineProperty(Object, &quot;myAssign&quot;, &#123; value : ObjectAssign, writable: true, enumerable: false, configurable: true &#125;);&#125;复制代码 十二、 map![img](data:image/svg+xml;utf8,) 12345678910111213141516171819202122Array.prototype.myMap &#x3D; function(fn) &#123; &#x2F;&#x2F; 判断输入的第一个参数是不是函数 if (typeof fn !&#x3D;&#x3D; &#39;function&#39;) &#123; throw new TypeError(fn + &#39;is not a function&#39;); &#125; &#x2F;&#x2F; 获取需要处理的数组内容 const arr &#x3D; this; const len &#x3D; arr.length; &#x2F;&#x2F; 新建一个空数组用于装载新的内容 const temp &#x3D; new Array(len); &#x2F;&#x2F; 对数组中每个值进行处理 for (let i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; 获取第二个参数，改变this指向 let result &#x3D; fn.call(arguments[1], arr[i], i, arr); temp[i] &#x3D; result; &#125; &#x2F;&#x2F; 返回新的结果 return temp;&#125;复制代码 十三、 filter![img](data:image/svg+xml;utf8,) 12345678910111213141516171819202122Array.prototype.myFilter &#x3D; function (fn) &#123; if (typeof fn !&#x3D;&#x3D; &#39;function&#39;) &#123; throw new TypeError(&#96;$&#123;fn&#125; is not a function&#96;); &#125; &#x2F;&#x2F; 获取该数组 const arr &#x3D; this; &#x2F;&#x2F; 获取该数组长度 const len &#x3D; this.length &gt;&gt;&gt; 0; &#x2F;&#x2F; 新建一个新的数组用于放置该内容 const temp &#x3D; []; &#x2F;&#x2F; 对数组中每个值进行处理 for (let i &#x3D; 0; i &lt; len; i++) &#123; &#x2F;&#x2F; 处理时注意this指向 const result &#x3D; fn.call(arguments[1], arr[i], i, arr); result &amp;&amp; temp.push(arr[i]); &#125; return temp;&#125;复制代码 十四、 reduce![img](data:image/svg+xml;utf8,) 123456789101112131415161718192021222324252627282930313233Array.prototype.myReduce &#x3D; function(fn) &#123; if (typeof fn !&#x3D;&#x3D; &#39;function&#39;) &#123; throw new TypeError(&#96;$&#123;fn&#125; is not a function&#96;); &#125; const arr &#x3D; this; const len &#x3D; arr.length &gt;&gt;&gt; 0; let value;&#x2F;&#x2F; 最终返回的值 let k &#x3D; 0;&#x2F;&#x2F; 当前索引 if (arguments.length &gt;&#x3D; 2) &#123; value &#x3D; arguments[1]; &#125; else &#123; &#x2F;&#x2F; 当数组为稀疏数组时，判断数组当前是否有元素，如果没有索引加一 while (k &lt; len &amp;&amp; !( k in arr)) &#123; k++; &#125; &#x2F;&#x2F; 如果数组为空且初始值不存在则报错 if (k &gt;&#x3D; len) &#123; throw new TypeError(&#39;Reduce of empty array with no initial value&#39;); &#125; value &#x3D; arr[k++]; &#125; while (k &lt; len) &#123; if (k in arr) &#123; value &#x3D; fn(value, arr[k], k, arr); &#125; k++; &#125; return value;&#125;复制代码 十五、 flat![img](data:image/svg+xml;utf8,) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#x2F;&#x2F; 使用reduce和concatArray.prototype.flat1 &#x3D; function () &#123; return this.reduce((acc, val) &#x3D;&gt; acc.concat(val), []);&#125;复制代码&#x2F;&#x2F; 使用reduce + concat + isArray +recursivityArray.prototype.flat2 &#x3D; function (deep &#x3D; 1) &#123; const flatDeep &#x3D; (arr, deep &#x3D; 1) &#x3D;&gt; &#123; &#x2F;&#x2F; return arr.reduce((acc, val) &#x3D;&gt; Array.isArray(val) &amp;&amp; deep &gt; 0 ? [...acc, ...flatDeep(val, deep - 1)] : [...acc, val], []); return deep &gt; 0 ? arr.reduce((acc, val) &#x3D;&gt; acc.concat(Array.isArray(val) ? flatDeep(val, deep - 1) : val), []) : arr.slice(); &#125; return flatDeep(this, deep);&#125;复制代码&#x2F;&#x2F; 使用forEach + concat + isArray +recursivity&#x2F;&#x2F; forEach 遍历数组会自动跳过空元素Array.prototype.flat3 &#x3D; function (deep &#x3D; 1) &#123; const result &#x3D; []; (function flat(arr, deep) &#123; arr.forEach((item) &#x3D;&gt; &#123; if (Array.isArray(item) &amp;&amp; deep &gt; 0) &#123; flat(item, deep - 1); &#125; else &#123; result.push(item); &#125; &#125;) &#125;)(this, deep); return result;&#125;复制代码&#x2F;&#x2F; 使用for of + concat + isArray +recursivity&#x2F;&#x2F; for of 遍历数组会自动跳过空元素Array.prototype.flat4 &#x3D; function (deep &#x3D; 1) &#123; const result &#x3D; []; (function flat(arr, deep) &#123; for(let item of arr) &#123; if (Array.isArray(item) &amp;&amp; deep &gt; 0) &#123; flat(item, deep - 1); &#125; else &#123; &#x2F;&#x2F; 去除空元素，因为void 表达式返回的都是undefined，不适用undefined是因为undefined在局部变量会被重写 item !&#x3D;&#x3D; void 0 &amp;&amp; result.push(item); &#125; &#125; &#125;)(this, deep); return result;&#125;复制代码&#x2F;&#x2F; 使用堆栈stackArray.prototype.flat5 &#x3D; function(deep &#x3D; 1) &#123; const stack &#x3D; [...this]; const result &#x3D; []; while (stack.length &gt; 0) &#123; const next &#x3D; stack.pop(); if (Array.isArray(next)) &#123; stack.push(...next); &#125; else &#123; result.push(next); &#125; &#125; &#x2F;&#x2F; 反转恢复原来顺序 return result.reverse();&#125;复制代码 十六、 call![img](data:image/svg+xml;utf8,) 12345678910111213Function.prototype.call1 &#x3D; function(context, ...args) &#123; &#x2F;&#x2F; 获取第一个参数（注意第一个参数为null或undefined是，this指向window），构建对象 context &#x3D; context ? Object(context) : window; &#x2F;&#x2F; 将对应函数传入该对象中 context.fn &#x3D; this; &#x2F;&#x2F; 获取参数并执行相应函数 let result &#x3D; context.fn(...args); delete context.fn; return result;&#125; 复制代码 十七、 apply![img](data:image/svg+xml;utf8,) 1234567891011Function.prototype.apply1 &#x3D; function(context, arr) &#123; context &#x3D; context ? Object(context) : window; context.fn &#x3D; this; let result &#x3D; arr ? context.fn(...arr) : context.fn(); delete context.fn; return result;&#125;复制代码 十八、 bind![img](data:image/svg+xml;utf8,) 12345678910111213141516171819202122Function.prototype.bind1 &#x3D; function (context, ...args) &#123; if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123; throw new TypeError(&#39;The bound object needs to be a function&#39;); &#125; const self &#x3D; this; const fNOP &#x3D; function() &#123;&#125;; const fBound &#x3D; function(...fBoundArgs) &#123; &#x2F;&#x2F; 指定this &#x2F;&#x2F; 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true return self.apply(this instanceof fNOP ? this : context, [...args, ...fBoundArgs]); &#125; &#x2F;&#x2F; 修改返回函数的 prototype 为绑定函数的 prototype,为了避免直接修改this的原型，所以新建了一个fNOP函数作为中介 if (this.prototype) &#123; fNOP.prototype &#x3D; this.prototype; &#125; fBound.prototype &#x3D; new fNOP(); return fBound;&#125;复制代码 十九、 防抖![img](data:image/svg+xml;utf8,) 12345678910111213141516function debounce(fn, wait, immediate) &#123; let timer &#x3D; null; return function(...args) &#123; &#x2F;&#x2F; 立即执行的功能(timer为空表示首次触发) if (immediate &amp;&amp; !timer) &#123; fn.apply(this, args); &#125; &#x2F;&#x2F; 有新的触发，则把定时器清空 timer &amp;&amp; clearTimeout(timer); &#x2F;&#x2F; 重新计时 timer &#x3D; setTimeout(() &#x3D;&gt; &#123; fn.apply(this, args); &#125;, wait) &#125;&#125;复制代码 二十、 节流![img](data:image/svg+xml;utf8,) 123456789101112131415161718192021222324252627&#x2F;&#x2F; 时间戳版本function throttle(fn, wait) &#123; &#x2F;&#x2F; 上一次执行时间 let previous &#x3D; 0; return function(...args) &#123; &#x2F;&#x2F; 当前时间 let now &#x3D; +new Date(); if (now - previous &gt; wait) &#123; previous &#x3D; now; fn.apply(this, args); &#125; &#125;&#125;复制代码&#x2F;&#x2F; 定时器版本function throttle(fn, wait) &#123; let timer &#x3D; null; return function(...args) &#123; if (!timer) &#123; timer &#x3D; setTimeout(() &#x3D;&gt; &#123; fn.apply(this, args); timer &#x3D; null; &#125;, wait) &#125; &#125;&#125;复制代码 二十一、深拷贝![img](data:image/svg+xml;utf8,) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;&#x2F; 乞巧版function cloneDeep1(source) &#123; return JSON.parse(JSON.stringify(source));&#125;复制代码&#x2F;&#x2F; 递归版function cloneDeep2(source) &#123; &#x2F;&#x2F; 如果输入的为基本类型，直接返回 if (!(typeof source &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; source !&#x3D;&#x3D; null)) &#123; return source; &#125; &#x2F;&#x2F; 判断输入的为数组函数对象，进行相应的构建 const target &#x3D; Array.isArray(source) ? [] : &#123;&#125;; for (let key in source) &#123; &#x2F;&#x2F; 判断是否是自身属性 if (Object.prototype.hasOwnProperty.call(source, key)) &#123; if (typeof source &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; source !&#x3D;&#x3D; null) &#123; target[key] &#x3D; cloneDeep2(source[key]); &#125; else &#123; target[key] &#x3D; source[key]; &#125; &#125; &#125; return target;&#125;复制代码&#x2F;&#x2F; 循环方式function cloneDeep3(source) &#123; if (!(typeof source &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; source !&#x3D;&#x3D; null)) &#123; return source; &#125; const root &#x3D; Array.isArray(source) ? [] : &#123;&#125;; &#x2F;&#x2F; 定义一个栈 const loopList &#x3D; [&#123; parent: root, key: undefined, data: source, &#125;]; while (loopList.length &gt; 0) &#123; &#x2F;&#x2F; 深度优先 const node &#x3D; loopList.pop(); const parent &#x3D; node.parent; const key &#x3D; node.key; const data &#x3D; node.data; &#x2F;&#x2F; 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素 let res &#x3D; parent; if (typeof key !&#x3D;&#x3D; &#39;undefined&#39;) &#123; res &#x3D; parent[key] &#x3D; Array.isArray(data) ? [] : &#123;&#125;; &#125; for (let key in data) &#123; if (data.hasOwnProperty(key)) &#123; if (typeof data[key] &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; data !&#x3D;&#x3D; null) &#123; loopList.push(&#123; parent: res, key: key, data: data[key], &#125;); &#125; else &#123; res[key] &#x3D; data[key]; &#125; &#125; &#125; &#125; return root;&#125;复制代码 二十二、 根据Promise/A+规范实现Promise 人家有相关标准，我们就要遵守，毕竟遵纪守法才是好公民，现在只能硬着头皮把这个标准过一遍。 ![img](data:image/svg+xml;utf8,) 下面就是基于Promise/A+规范实现的代码，已经经过promises-aplus-tests库进行了验证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136const PENDING &#x3D; &#39;pending&#39;;const FULFILLED &#x3D; &#39;fulfilled&#39;;const REJECTED &#x3D; &#39;rejected&#39;;&#x2F;** * Promise构造函数 * excutor: 内部同步执行的函数 *&#x2F;class Promise &#123; constructor(excutor) &#123; const self &#x3D; this; self.status &#x3D; PENDING; self.onFulfilled &#x3D; [];&#x2F;&#x2F; 成功的回调 self.onRejected &#x3D; [];&#x2F;&#x2F; 失败的回调 &#x2F;&#x2F; 异步处理成功调用的函数 &#x2F;&#x2F; PromiseA+ 2.1 状态只能由Pending转为fulfilled或rejected；fulfilled状态必须有一个value值；rejected状态必须有一个reason值。 function resolve(value) &#123; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; self.status &#x3D; FULFILLED; self.value &#x3D; value; &#x2F;&#x2F; PromiseA+ 2.2.6.1 相同promise的then可以被调用多次，当promise变为fulfilled状态，全部的onFulfilled回调按照原始调用then的顺序执行 self.onFulfilled.forEach(fn &#x3D;&gt; fn()); &#125; &#125; function reject(reason) &#123; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; self.status &#x3D; REJECTED; self.reason &#x3D; reason; &#x2F;&#x2F; PromiseA+ 2.2.6.2 相同promise的then可以被调用多次，当promise变为rejected状态，全部的onRejected回调按照原始调用then的顺序执行 self.onRejected.forEach(fn &#x3D;&gt; fn()); &#125; &#125; try &#123; excutor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125; then(onFulfilled, onRejected) &#123; &#x2F;&#x2F; PromiseA+ 2.2.1 onFulfilled和onRejected是可选参数 &#x2F;&#x2F; PromiseA+ 2.2.5 onFulfilled和onRejected必须被作为函数调用 &#x2F;&#x2F; PromiseA+ 2.2.7.3 如果onFulfilled不是函数且promise1状态是fulfilled，则promise2有相同的值且也是fulfilled状态 &#x2F;&#x2F; PromiseA+ 2.2.7.4 如果onRejected不是函数且promise1状态是rejected，则promise2有相同的值且也是rejected状态 onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : value &#x3D;&gt; value; onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : reason &#x3D;&gt; &#123; throw reason &#125;; const self &#x3D; this; const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; const handle &#x3D; (callback, data) &#x3D;&gt; &#123; &#x2F;&#x2F; PromiseA+ 2.2.4 onFulfilled或者onRejected需要在自己的执行上下文栈里被调用，所以此处用setTimeout setTimeout(() &#x3D;&gt; &#123; try &#123; &#x2F;&#x2F; PromiseA+ 2.2.2 如果onFulfilled是函数，则在fulfilled状态之后调用，第一个参数为value &#x2F;&#x2F; PromiseA+ 2.2.3 如果onRejected是函数，则在rejected状态之后调用，第一个参数为reason const x &#x3D; callback(data); &#x2F;&#x2F; PromiseA+ 2.2.7.1 如果onFulfilled或onRejected返回一个x值，运行这[[Resolve]](promise2, x) resolvePromise(promise, x, resolve, reject); &#125; catch (e) &#123; &#x2F;&#x2F; PromiseA+ 2.2.7.2 onFulfilled或onRejected抛出一个异常e，promise2必须以e的理由失败 reject(e); &#125; &#125;) &#125; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; self.onFulfilled.push(() &#x3D;&gt; &#123; handle(onFulfilled, self.value); &#125;); self.onRejected.push(() &#x3D;&gt; &#123; handle(onRejected, self.reason); &#125;) &#125; else if (self.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123; setTimeout(() &#x3D;&gt; &#123; handle(onFulfilled, self.value); &#125;) &#125; else if (self.status &#x3D;&#x3D;&#x3D; REJECTED) &#123; setTimeout(() &#x3D;&gt; &#123; handle(onRejected, self.reason); &#125;) &#125; &#125;) return promise; &#125;&#125;function resolvePromise(promise, x, resolve, reject) &#123; &#x2F;&#x2F; PromiseA+ 2.3.1 如果promise和x引用同一对象，会以TypeError错误reject promise if (promise &#x3D;&#x3D;&#x3D; x) &#123; reject(new TypeError(&#39;Chaining Cycle&#39;)); &#125; if (x &amp;&amp; typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; &#x2F;&#x2F; PromiseA+ 2.3.3.3.3 如果resolvePromise和rejectPromise都被调用，或者对同一个参数进行多次调用，那么第一次调用优先，以后的调用都会被忽略。 let used; try &#123; &#x2F;&#x2F; PromiseA+ 2.3.3.1 let then be x.then &#x2F;&#x2F; PromiseA+ 2.3.2 调用then方法已经包含了该条（该条是x是promise的处理）。 let then &#x3D; x.then; if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; &#x2F;&#x2F; PromiseA+ 2.3.3.3如果then是一个函数，用x作为this调用它。第一个参数是resolvePromise，第二个参数是rejectPromise &#x2F;&#x2F; PromiseA+ 2.3.3.3.1 如果resolvePromise用一个值y调用，运行[[Resolve]](promise, y) &#x2F;&#x2F; PromiseA+ 2.3.3.3.2 如果rejectPromise用一个原因r调用，用r拒绝promise。 then.call(x, (y) &#x3D;&gt; &#123; if (used) return; used &#x3D; true; resolvePromise(promise, y, resolve, reject) &#125;, (r) &#x3D;&gt; &#123; if (used) return; used &#x3D; true; reject(r); &#125;) &#125; else &#123; &#x2F;&#x2F; PromiseA+ 如果then不是一个函数，变为fulfilled状态并传值为x if (used) return; used &#x3D; true; resolve(x); &#125; &#125; catch (e) &#123; &#x2F;&#x2F; PromiseA+ 2.3.3.2 如果检索属性x.then抛出异常e，则以e为原因拒绝promise &#x2F;&#x2F; PromiseA+ 2.3.3.4 如果调用then抛出异常，但是resolvePromise或rejectPromise已经执行，则忽略它 if (used) return; used &#x3D; true; reject(e); &#125; &#125; else &#123; &#x2F;&#x2F; PromiseA+ 2.3.4 如果x不是一个对象或函数，状态变为fulfilled并传值x resolve(x); &#125;&#125;复制代码 二十三、 Promise.resolve()![img](data:image/svg+xml;utf8,) 12345678910111213141516171819202122232425262728class Promise &#123; &#x2F;&#x2F; ... &#x2F;&#x2F; 将现有对象转为 Promise 对象 static resolve(value) &#123; &#x2F;&#x2F; 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 if (value instanceof Promise) return value; &#x2F;&#x2F; 参数是一个thenable对象（具有then方法的对象）,Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof value &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; try &#123; let then &#x3D; value.then; if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; return new Promise(then.bind(value)); &#125; &#125; catch (e) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; reject(e); &#125;) &#125; &#125; &#x2F;&#x2F; 参数不是具有then方法的对象，或根本就不是对象,Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 return new Promise((resolve, reject) &#x3D;&gt; &#123; resolve(value); &#125;) &#125;&#125;复制代码 二十四、 Promise.reject()![img](data:image/svg+xml;utf8,) 12345678910class Promise &#123; &#x2F;&#x2F; ... &#x2F;&#x2F; 返回一个新的 Promise 实例，该实例的状态为rejected。 static reject(reason) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; reject(reason); &#125;) &#125;&#125;复制代码 二十五、 Promise.all()![img](data:image/svg+xml;utf8,) 12345678910111213141516171819202122class Promise &#123; &#x2F;&#x2F; ... &#x2F;&#x2F; 用于将多个 Promise 实例，包装成一个新的 Promise 实例。只有所有状态都变为fulfilled，p的状态才会是fulfilled static all(promises) &#123; const values &#x3D; []; let resolvedCount &#x3D; 0; return new Promise((resolve, reject) &#x3D;&gt; &#123; promises.forEach((p, index) &#x3D;&gt; &#123; Promise.resolve(p).then(value &#x3D;&gt; &#123; resolvedCount++; values[index] &#x3D; value; if (resolvedCount &#x3D;&#x3D;&#x3D; promises.length) &#123; resolve(values); &#125; &#125;, reason &#x3D;&gt; &#123; reject(reason); &#125;) &#125;) &#125;) &#125;&#125;复制代码 二十六、 Promise.race()![img](data:image/svg+xml;utf8,) 12345678910111213141516class Promise &#123; &#x2F;&#x2F; ... &#x2F;&#x2F; 只要有一个实例率先改变状态，状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给回调函数。 static race(promises) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; promises.forEach((p, index) &#x3D;&gt; &#123; Promise.resolve(p).then(value &#x3D;&gt; &#123; resolve(value); &#125;, reason &#x3D;&gt; &#123; reject(reason); &#125;) &#125;) &#125;) &#125;&#125;复制代码 二十七、 Promise.catch()![img](data:image/svg+xml;utf8,) 12345678class Promise &#123; &#x2F;&#x2F; ... &#x2F;&#x2F; 是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125;&#125;复制代码 二十八、 Promise.finally()![img](data:image/svg+xml;utf8,) 1234567891011class Promise &#123; &#x2F;&#x2F; ... &#x2F;&#x2F; 用于指定不管 Promise 对象最后状态如何，都会执行的操作。 finally(callback) &#123; return this.then( value &#x3D;&gt; Promise.resolve(callback()).then(() &#x3D;&gt; value), reason &#x3D;&gt; Promise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;) ) &#125;&#125;复制代码 二十九、Async实现原理![img](data:image/svg+xml;utf8,) 这是Async的实现原理，即将Generator函数作为参数放入run函数中，最终实现自动执行并返回Promise对象。 12345678910111213141516171819202122232425262728293031function run(genF) &#123; &#x2F;&#x2F; 返回值是Promise return new Promise((resolve, reject) &#x3D;&gt; &#123; const gen &#x3D; genF(); function step(nextF) &#123; let next; try &#123; &#x2F;&#x2F; 执行该函数，获取一个有着value和done两个属性的对象 next &#x3D; nextF(); &#125; catch (e) &#123; &#x2F;&#x2F; 出现异常则将该Promise变为rejected状态 reject(e); &#125; &#x2F;&#x2F; 判断是否到达末尾，Generator函数到达末尾则将该Promise变为fulfilled状态 if (next.done) &#123; return resolve(next.value); &#125; &#x2F;&#x2F; 没到达末尾，则利用Promise封装该value，直到执行完毕，反复调用step函数，实现自动执行 Promise.resolve(next.value).then((v) &#x3D;&gt; &#123; step(() &#x3D;&gt; gen.next(v)) &#125;, (e) &#x3D;&gt; &#123; step(() &#x3D;&gt; gen.throw(e)) &#125;) &#125; step(() &#x3D;&gt; gen.next(undefined)); &#125;)&#125;复制代码 三十、发布订阅模式![img](data:image/svg+xml;utf8,) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#x2F;&#x2F; 发布订阅（TypeScript版）interface Publish &#123; registerObserver(eventType : string, subscribe : Subscribe) : void; remove(eventType : string, subscribe ?: Subscribe) : void; notifyObservers(eventType : string) : void;&#125;interface SubscribesObject&#123; [key : string] : Array&lt;Subscribe&gt;&#125;class ConcretePublish implements Publish &#123; private subscribes : SubscribesObject; constructor() &#123; this.subscribes &#x3D; &#123;&#125;; &#125; registerObserver(eventType : string, subscribe : Subscribe) : void &#123; if (!this.subscribes[eventType]) &#123; this.subscribes[eventType] &#x3D; []; &#125; this.subscribes[eventType].push(subscribe); &#125; remove(eventType : string, subscribe ?: Subscribe) : void &#123; const subscribeArray &#x3D; this.subscribes[eventType]; if (subscribeArray) &#123; if (!subscribe) &#123; delete this.subscribes[eventType]; &#125; else &#123; for (let i &#x3D; 0; i &lt; subscribeArray.length; i++) &#123; if (subscribe &#x3D;&#x3D;&#x3D; subscribeArray[i]) &#123; subscribeArray.splice(i, 1); &#125; &#125; &#125; &#125; &#125; notifyObservers(eventType : string, ...args : any[]) : void &#123; const subscribes &#x3D; this.subscribes[eventType]; if (subscribes) &#123; subscribes.forEach(subscribe &#x3D;&gt; subscribe.update(...args)) &#125; &#125;&#125;interface Subscribe &#123; update(...value : any[]) : void;&#125;class ConcreteSubscribe1 implements Subscribe &#123; public update(...value : any[]) : void &#123; console.log(&#39;已经执行更新操作1，值为&#39;, ...value); &#125;&#125;class ConcreteSubscribe2 implements Subscribe &#123; public update(...value : any[]) : void &#123; console.log(&#39;已经执行更新操作2，值为&#39;, ...value); &#125;&#125;function main() &#123; const publish &#x3D; new ConcretePublish(); const subscribe1 &#x3D; new ConcreteSubscribe1(); const subscribe2 &#x3D; new ConcreteSubscribe2(); publish.registerObserver(&#39;1&#39;, subscribe1); publish.registerObserver(&#39;2&#39;, subscribe2); publish.notifyObservers(&#39;2&#39;, &#39;22222&#39;);&#125;main();复制代码 三十一、懒加载 1)首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。 2)页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。 3)在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。 elementNode.getAttribute(name)：方法通过名称获取属性的值。 elementNode.setAttribute(name, value)：方法创建或改变某个新属性。 elementNode.removeAttribute(name)：方法通过名称删除属性的值。 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F;懒加载代码实现var viewHeight &#x3D; document.documentElement.clientHeight;&#x2F;&#x2F;可视化区域的高度function lazyload () &#123; &#x2F;&#x2F;获取所有要进行懒加载的图片 let eles &#x3D; document.querySelectorAll(&#39;img[data-original][lazyload]&#39;);&#x2F;&#x2F;获取属性名中有data-original的 Array.prototype.forEach.call(eles, function(item, index) &#123; let rect; if(item.dataset.original &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123; return; &#125; rect &#x3D; item.getBoundingClientRect(); &#x2F;&#x2F;图片一进入可视区，动态加载 if(rect.bottom &gt;&#x3D; 0 &amp;&amp; rect.top &lt; viewHeight) &#123; !function () &#123; let img &#x3D; new Image(); img.src &#x3D; item.dataset.original; img.onload &#x3D; function () &#123; item.src &#x3D; img.src; &#125; item.removeAttribute(&#39;data-original&#39;); item.removeAttribute(&#39;lazyload&#39;); &#125;(); &#125; &#125;)&#125;lazyload();document.addEventListener(&#39;scroll&#39;, lazyload);复制代码 三十二、FileReader使用123456789101112131415161718192021222324252627282930function uploadMulFile(uploadFile) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; let fileLength &#x3D; 0; let reader &#x3D; new FileReader(); reader.readAsText(uploadFile[fileLength]); reader.onabort &#x3D; function(e) &#123; console.log(&quot;文件读取异常&quot;); &#125; reader.onerror &#x3D; function(e) &#123; console.log(&quot;文件读取错误&quot;); &#125; reader.onload &#x3D; function(e)&#123; if(e.target.result) &#123; fileLength++; if(fileLength &lt; uploadFile.length) &#123; reader.readAsText(uploadFile[fileLength]); &#125;else&#123; resolve(&#123; carArr, crossArr, roadArr &#125;) &#125; &#125; &#125; &#125;)&#125;复制代码 三十三、Ajax使用（非Promise版）12345678910111213141516171819202122232425262728function ajax(url) &#123; var XHR; &#x2F;&#x2F;进行性能检测 if(window.ActiveXObject) &#123; XHR &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#x2F;&#x2F;兼容IE&#x2F;&#x2F;IE浏览器中使用的请求的方法，需实例化 &#125;else if(window.XMLHttpRequest) &#123; XHR &#x3D; new XMLHttpRequest();&#x2F;&#x2F;标准浏览器中的使用的请求方法，需实例化 &#125;else&#123; XHR &#x3D; null; &#125; if(XHR) &#123; XHR.onreadystatechange &#x3D; function() &#123; &#x2F;&#x2F;readyState:Ajax请求服务的状态 if(XHR.readyState &#x3D;&#x3D; 4) &#123; &#x2F;&#x2F;status：页面的响应码 if(XHR.status &#x3D;&#x3D; 200) &#123; &#x2F;&#x2F;返回的数据以string的形式返回 console.log(XHR.responseText); &#125; &#125; &#125;; XHR.open(&quot;get&quot;, url);&#x2F;&#x2F;open(‘method’,‘url’,boolean)；参数1：请求方式；参数2：请求文件的地址；参数3：设置是否异步，true表示异步， 默认值为 true 所以可以不写。 XHR.send(); &#125;&#125;复制代码 三十四、Ajax使用（Promise版）12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;Promise形式function ajaxPromise(method, url, data) &#123; var xhr &#x3D; null; if(window.ActiveXObject) &#123; xhr &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;else&#123; xhr &#x3D; new XMLHttpRequest(); &#125; return new Promise(function(resolve, reject) &#123; xhr.onreadystatechange &#x3D; function()&#123; if(xhr.readyState &#x3D;&#x3D;&#x3D; 4 ) &#123; if(xhr.status &#x3D;&#x3D;&#x3D; 200) &#123; resolve(JSON.parse(xhr.responseText)); &#125;else&#123; reject(xhr.status); &#125; &#125; &#125;; if(method.toUpperCase() &#x3D;&#x3D; &quot;GET&quot;) &#123; var arr &#x3D; []; for(var key in data) &#123; arr.push(key + &#39;&#x3D;&#39; + data[key]); &#125; var getData &#x3D; arr.join(&#39;&amp;&#39;); xhr.open(&quot;GET&quot;, url + &quot;?&quot; + getData, true);&#x2F;&#x2F;true表示异步 xhr.send(null); &#125;else if(method.toUpperCase() &#x3D;&#x3D; &quot;POST&quot;) &#123; xhr.open(&quot;POST&quot;, url, true); xhr.responseType &#x3D; &quot;json&quot;; xhr.setRequestHeader(&#39;Content&#39;, &#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8&#39;); xhr.send(data); &#125; &#125;)&#125;复制代码 三十五、JsonP123456789101112131415161718192021222324252627282930313233343536373839404142function jsonp(url, onsuccess, onerror, charset) &#123; var hash &#x3D; Math.random().toString().slice(2); window[&#39;jsonp&#39; + hash] &#x3D; function(data) &#123; if(onsuccess &amp;&amp; typeof onsuccess &#x3D;&#x3D; &#39;function&#39;) &#123; onsuccess(data); &#125; &#125; var script &#x3D; createScript(url + &quot;?callback&#x3D;jsonp&quot; + hash, charset); &#x2F;&#x2F; 动态产检一个script标签 &#x2F;&#x2F;监听加载成功的事件，获取数据，这个位置用了两个事件onload和onreadystatechange是为了兼容IE，因为IE9之前不支持onload事件，只支持onreadystatechange事件 script.onload &#x3D; script.onreadystatechange &#x3D; function() &#123; &#x2F;&#x2F;若不存在readyState事件则证明不是IE浏览器，可以直接执行，若是的话，必须等到状态变为loaded或complete才可以执行 if(!this.readyState || this.readyState &#x3D;&#x3D; &#39;loaded&#39; || this.readyState &#x3D;&#x3D; &#39;complete&#39;) &#123; script.onload &#x3D; script.onreadystatechange &#x3D; null; &#x2F;&#x2F; 移除该script的DOM对象 if(script.parentNode) &#123; script.parentNode.removeChild(script); &#125; &#x2F;&#x2F;删除函数或变量 window[&#39;jsonp&#39; + hash] &#x3D; null; &#125; &#125; script.onerror &#x3D; function () &#123; if(onerror &amp;&amp; typeof onerror &#x3D;&#x3D; &#39;function&#39;) &#123; onerror(); &#125; &#125; document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);&#x2F;&#x2F;往html中增加这个标签，目的是把请求发送出去&#125;function createScript(url, charset) &#123; var script &#x3D; document.createElement(&#39;script&#39;); script.setAttribute(&#39;type&#39;, &#39;text&#x2F;javascript&#39;); charset &amp;&amp; script.setAttribute(&#39;charset&#39;, charset); script.setAttribute(&#39;src&#39;, url); script.async &#x3D; true;&#125;复制代码 三十六、将一个字符串转换为驼峰形式1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F;方式一：操作字符串数组function transformStr2Hump1(str) &#123; if(str &#x3D;&#x3D; null) &#123; return &quot;&quot;; &#125; var strArr &#x3D; str.split(&#39;-&#39;); for(var i &#x3D; 1; i &lt; strArr.length; i++) &#123; strArr[i] &#x3D; strArr[i].charAt(0).toUpperCase() + strArr[i].substring(1); &#125; return strArr.join(&#39;&#39;);&#125;&#x2F;&#x2F;方式二：操作字符数组function transformStr2Hump2(str) &#123; if(str &#x3D;&#x3D; null) &#123; return &quot;&quot;; &#125; var strArr &#x3D;str.split(&#39;&#39;); for(var i &#x3D; 0; i &lt; strArr.length; i++) &#123; if(strArr[i] &#x3D;&#x3D; &quot;-&quot;)&#123; &#x2F;&#x2F;删除- strArr.splice(i, 1); &#x2F;&#x2F;将该处改为大写 if(i &lt; strArr.length) &#123; strArr[i] &#x3D; strArr[i].toUpperCase(); &#125; &#125; &#125; return strArr.join(&quot;&quot;);&#125;&#x2F;&#x2F;方式三：利用正则function transformStr2Hump3(str) &#123; if(str &#x3D;&#x3D; null) &#123; return &quot;&quot;; &#125; var reg &#x3D; &#x2F;-(\\w)&#x2F;g;&#x2F;&#x2F;匹配字母或数字或下划线或汉字 return str.replace(reg, function($0, $1) &#123; return $1.toUpperCase(); &#125;)&#125;","categories":[],"tags":[]},{"title":"JS笔记","slug":"JS笔记","date":"2020-09-07T08:58:23.028Z","updated":"2020-11-05T09:07:34.086Z","comments":true,"path":"2020/09/07/JS笔记/","link":"","permalink":"http://example.com/2020/09/07/JS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.面向对象：根据需求，抽象出相关的对象，总结对象的行为和特征，把特征变成属性，行为变成方法，然后定义（js）构造函数，实例化对象，通过对象调用属性和方法，完成相应的需求。 2.定时器 var a = setInterval(function () { },150) 反复调用 停止 clearInterval(a) setTimeout()调用一次 clearTimeout() 3.函数调用3中普通函数function f1(){ console.log(“11”)} f1() 构造函数function F1(){ console.log(11)} var f =new F1() 对象方法function f2(){ this.paly = function(){ console.log(11) }} var f = new f2 f.play() 4.创建对象的三种方法1.字面量的方式var obj = { age:10, sex:’男’, say:function(){ console.log(“hi”) }} 2.调用系统的构造函数var obj2 = new object(); obj2.age = 20; obj2.sex = “nan”; obj2.say = function(){ console.log(hi) } 3.自定义构造函数function person(name,age){ this.name = name; this,age = age; this.say = function(){ console.log(hi) } var Jn = new person(“江楠”,20) 4.function中有 return得拿 var X 接收 然后console.log(x) 立即执行 ，return 之后的不执行 默认返回undefined 不return在其他方法里用不了 5.apply 和 call都可以改变this指向 传谁指向谁 调用的时候改变this指向区别 apply 只能传 this 和数组[a,b] call 可以传多个参数 this,a,b,c 6.bind的方法是复制参数可以在复制的时候传递，也可以在复制之后调用的时候复制的时候改变this指向7.函数中的属性name:只读 不能修改 arguments:实参个数 length:形参个数 caller:调用者 8.排序 sortvar a = [12,112,50,55,24,8,57,9] a.sort(function (a , b ) { return a-b }) console.log(a) 9.substr() 截取字符串10.浅拷贝（复制属性） function extend(a,b){for(var key in a ){ b[key] = a[key] } }数组的四个新方法11.map 映射 （一个对一个）12.reduce 汇总 （一堆出来一个）13.filter 过滤器14.foreach 迭代15.字符串的两个新方法15.1 startWith 判断以什么什么开头15.2 endsWith 判断以什么什么结尾16.字符串模板 ``17. …args18.面向对象 class类class a{ constructor(name,pass){ this.name = name this.pass = pass } } 继承class b extends a{ constructor(name,pass,b){ super(name,pass) this.b = b } } 19.jsonJSON.stringify(json)JSON.parse()用法：https://www.cnblogs.com/echolun/p/9631836.html 20.encodeURIComponent()函数可把字符串作为 URI 组件进行编码 21.json的标准写法21.1只能用双引号21.2所有的名字都必须用引号包起来{“a”:12,”b”:”5”} 22.Promise 承诺 消除异步操作 用同步一样的方式，来书写异步代码Promise.all([]) https://www.jianshu.com/p/1b63a13c2701 new Promise((resolve,reject) =&gt;{ setTimeout(()=&gt;{ resolve() },1000) ​ }）.then(()=&gt;{ console.log(aaaa) return new Promise((resolve,reject)=&gt;{ }) }) 23.异步：操作之间没啥关系，同时进行多个操作24.同步：同时只能做一件事25.generator-生成器函数 踹一脚走一步function *show(){ yield } https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112 26.解构赋值 左右结构一样let [a,b,c] = [12,5,8] axios跨域 数字方法 .popvar array = [1,8,2,7,9,4] var arr = ‘’ while (array.length!=0) { arr += array.pop() } console.log(arr) 29.第一个数组删除 加入最后array.push(array.shift()) 30.插入数组.splicearray.splice(2,0,7)在第二个位置插入7 31.indexOf ()出现的位置32.hasOwnProperty方法some() 判断自身属性是否存在 33.哈希表 解决冲突1.链地址法 2.开放地址法 34.不知道 循环多少次 用while循环35.二叉树第i层最大节点数是：2^(i-1),i&gt;=136.深度为k的二叉树 有最大节点总数为：2^k - 1,k&gt;=137.对任何非空二叉树T,若n0表示叶节点的个数，n2是是度为2的非叶节点个数，那么两者满足关系n0 = n2 +1 38.闭包： 一个持有外部环境变量的函数就是闭包。39.事件委托：把一个元素响应事件（click、keydown……）的函数委托到另一个元素40.用原生js实现，点击一个列表时，输出对应的索引 var ul = document.querySelector(“ul”); ul.addEventListener(“mousedown”, mouseHandler); function mouseHandler(e) { e.preventDefault(); if (e.target.nodeName !== “LI”) return; var arr = Array.from(ul.children); var index = arr.indexOf(e.target); console.log(index); } 41.pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或多个元素unshift()可向数组的开头添加一个或更多元素shift() 把数组的第一个元素从其中删除42.es6 去重var arr = [4,0,8,1,0,5,2,0,3] function unique(arr) { return Array.from(new Set(arr)) } document.write(unique(arr)+”“) 43.this指向1：this永远指向一个对象； 2：this的指向完全取决于函数调用的位置； 44.concat()拼接两个数组 返回一个新数组45.每次new 太麻烦 直接暴露 参考subscribe (自己封装的那个)46.replace（）替换47.jquery的each和原生的javascript 方法 foreach 区别foreach ecmascript 5 提供的 ie8一下不支持 jquery的each 由第三方库提供 它的each方法主要用来遍历jquery实例对象（伪数组） 同时他也是作为低版本浏览器foreach的替代品 JQuery的实例对象不能使用forEach方法 如果想要使用必须转为数组才能使用 48.find()123var XXX = XXX.find(item =&gt;&#123; item.id === XXX.id&#125;) 49.**Object.assign()**方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 50.findIndex()专门根据条件找下标51.原生js for in循环如果是索引值就是 in如果是值循环 是 of","categories":[],"tags":[]},{"title":"Vue笔记","slug":"Vue","date":"2020-09-07T08:45:12.818Z","updated":"2020-11-05T09:07:32.693Z","comments":true,"path":"2020/09/07/Vue/","link":"","permalink":"http://example.com/2020/09/07/Vue/","excerpt":"","text":"git笔记：创建项目复制地址git clone https://github.com/wen3ger/PersonalMall.git 生命周期 渲染函数 组件通信核心：object.defineProperty 发布者订阅模式 1.0项目1.1.划分目录结构1.2创建用户片段2.引用两个css文件3.别名配置4.创建.editorconfig文件5.安装router路由 npm install vue-router –save6.配置路由7.起别名 防止地址路径引用错误7.1 webpack.base.conf7.2 resolve7.3​ ‘assets’: resolve(‘@/assets’),​ ‘components’: resolve(‘@/components’),​ ‘route’: resolve(‘@/route’),​ ‘view’: resolve(‘@/view’), 8.一般导航高度44px 字体14px9.npm install axios –save 安装拦截器10.better-scroll 移动端滚动 .native 原生事件 点击12.防抖函数13.$bus Vue.prototype.$bus = new Vue() 14.git status 查看工作区代码相对于暂存区的差别git add . 将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录git commit -m ‘注释’ 将缓存区内容添加到本地仓库git pull origin master先将远程仓库master中的信息同步到本地仓库master中git push origin master 将本地版本库推送到远程服务器， 15.$el $refs.组件.$el 拿div元素 17.创建export class Goods {​ constructor(itemInfo, columns, services) {​ this.title = itemInfo.title;​ this.desc = itemInfo.desc; &#125; } 18.判断是不是空对象Object.keys(goods).length !== 0 19.箭头函数$nextTick( （）=&gt; { }) 20.vuex 1.Actions可以返回一个promise2.mapActions的映射关系21.善用transfrom22.移动端fastClick 减少点击延迟22.1 npm install fastclick –save22.2 main.js 导入 import FastClick from ‘fastclick’22.3 使用 FastClick.attach(document.body)23.图片懒加载https://www.cnblogs.com/xieli26/p/10057763.html 24.前端px转换成vh 自适应24.1 安装插件24.2 在postcss.config.js中配置25.instanceof （判断 变量XX instanceof XX是不是）26.swiper27.在methods写方法，在created中调用28.跳转@click=”$router.push”29.npm i inflection 类名转换30.上传图片插件npm i multer 31.//显示赋值data里面没有 ​ this.$set 32.如果数据直接覆盖data里面的数据，1Object.assign(&#123;&#125;,this.model,res.data); 33.富文本编辑器npm i –save vue2-editor 34.管理员密码加密1npm i bcrypt 35.密码校验1npm i jsonwebtoken 36.登录状态校验错误提示信息1npm i http-assert 37.引用scss1npm i -D sass sass-loader 38.精灵图 工具http://www.spritecow.com/ 39.第几个不要边框123&amp;:nth-child(4n+1)&#123; border-left:none; &#125; 40.跳转链接1&lt;router-link tag=&quot;div&quot; :to=&quot;`/articles/$&#123;news._id&#125;`&quot;&gt;&lt;/router-link&gt; 41.watch()监听什么数据发生改变123watch: &#123; id:&#x27;fetch&#x27; &#125;//id发生改变值 使用watch监听 重新调用fetch程序 41.1 数据发生改变（适用于链接跳转）1在main的router-view绑定key为$route.path也可以 和之前一样","categories":[],"tags":[]},{"title":"node笔记","slug":"node","date":"2020-09-07T06:42:23.517Z","updated":"2020-11-05T09:07:33.411Z","comments":true,"path":"2020/09/07/node/","link":"","permalink":"http://example.com/2020/09/07/node/","excerpt":"","text":"0.node没有作用域 只有模块作用域1.url 模块的使用url.parse(url,true).query解析url 2.自动更新npm install -g supervisor 3单独js文件 抽离成 作为模块exports暴露属性或者方法 或者module.exports = obj; 然后在需要的文件中 ，通过require引入 4.在文件夹里生成package.json对应目录下cmd 输入 npm init –yes 5.https://www.npmjs.com/ 包（引入包需要在需要的引入的文件夹里创建package.json）安装包的时候 要加入 –save 6.npm i 安装项目中 你本地没有的包7.安装指定版本包 在后面加@版本号8.fs//fs.stat 检测是文件还是目录 //fs.mkdir 创建目录 //fs.writeFile 创建写入文件 //fs.appendFile 追加文件 //fs.readFile 读取文件 //fs.readdir 读取目录 //fs.rename 重命名 //fs.rmdir 删除目录 //fs.unlink 删除文件 9.插件mkdirpnpm i mkdirp --save 10.Async,Await和PromiseAsync是让方法变成异步 await 是等待异步方法执行完成 https://www.bilibili.com/video/BV11t411k79h?p=8 10.fs中的流依旧管道流fs.createReadStream() 读取流fs.createWriteStream() 写入文件 流WriteStream.write(str) WriteStream.end() WriteStream.on(&#39;finish&#39;,()=&gt;&#123; &#125;) 需要导的文件.pipe（需要导入到的文件）管道流11.暴露1exports module.export 12.获取后缀名方法​ path.extname() 13.npm install ejs –save14.获取get传值 ***只能拿get请求参数.query 15.console.log(req.method);获取请求类型 12316. try &#123; &#125; catch (error) &#123;&#125; 17.服务器渲染插件 atr template1npm install art-template --save 18.url.parse true(query解析对象)19.JSON.stringify() 把数据转化为json20.json插件 jsonview21.input textarea 表单中必须要有name属性22.状态码设置3021res.statusCode = 302 23.在响应头通过location告诉客户端往哪里重定向123res.setHeader(&#x27;Location&#x27;,/) 22.23综合1res.redirect(&#x27;/&#x27;) 直接跳转 24.url.indexOf() ===0 判断是不是访问开放的地址1fs.readFile(&quot;.&quot;+url,function(err,data)) 25.var exports=module.exports26.npm install –save express-art-template 安装模板插件12app.engine(&#x27;html&#x27;, require(&#x27;express-art-template&#x27;));视图放在views文件夹 27.form表单提交123&lt;form action=&quot;/post&quot; method=&quot;post&quot;&gt; &lt;/from&gt; 12345678app.post(&#x27;/post&#x27;,function(req,res)&#123; //1.获取表单post请求数据 var comment = req.body //2.处理 comments.unshift(comment) //3.发送响应 res.redirect(&#x27;/&#x27;)&#125;) 28.在express获取表单post请求数据1.需要插件 中间件(在router之前) 123456789101112131415https://www.expressjs.com.cn/en/resources/middleware/body-parser.html$ npm install body-parservar bodyParser = require(&#x27;body-parser&#x27;)// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json())app.use(function (req, res) &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;) res.write(&#x27;you posted:\\n&#x27;) res.end(JSON.stringify(req.body, null, 2))&#125;) 29.string转对象``fs读取出来的数据 一定是字符串模板循环必须转成对象 JSON.parse(data) 30.做加密用postGET把参数包含在URL中，POST通过request body传递参数 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 31.router.js 12345678910111213//包装路由var express = require(&#x27;express&#x27;)//创建路由容器var router = express.Router()//把路由挂在到router 路由容器中router.get(&#x27;/&#x27;,function(req,res)&#123; &#125;)//导出routermodule.exports = router//在app.js中调用app.use(router) 32.往json中写数据12345678910111213141516171819//先读出来fs.readfile(&#x27;./json&#x27;,async function(err,data)=&gt;&#123; await JSON.parse(data).students&#125;&#125;)//然后往对象中push数据var dataNew = JSON.parse(data).students.push(list)//然后转成jsonthis.dataNew.stringify()//追加回去fs.writeFile(&#x27;./json&#x27;,json,err =&gt;&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(&#x27;创建成功&#x27;) &#125; &#125;) 33.通过url拿到的id是字符串 需要 1parseInt(req.query.id) 34.隐藏表单域 用来放一些不希望被用户看见 但需要被提交到服务端的数据 1&lt;input type=&quot;hidden&quot; value=&quot;xxx.id&quot; name=&quot;id&quot;&gt; 35.数据做关联时候的schema类型设置 1category:&#123;type:mongoose.SchemaTypes.ObjectId,ref:&#x27;Category&#x27;&#125;, 36.环境变量地址121.http.js baseURL:process.env.VUE_APP_API_URL || &#x27;/admin/api&#x27;,2.在admin/src添加.env.development文件夹","categories":[],"tags":[]}],"categories":[],"tags":[]}